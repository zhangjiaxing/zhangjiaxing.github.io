<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>cat ~/.zhiliao.history - programming</title><link href="/" rel="alternate"></link><link href="/feeds/feeds/programming.atom.xml" rel="self"></link><id>/</id><updated>2023-07-29T02:13:59+08:00</updated><subtitle>无聊就该多读书。</subtitle><entry><title>gdb的基本使用方法</title><link href="/posts/2023/07/29/gdb.html" rel="alternate"></link><published>2023-07-29T00:26:32+08:00</published><updated>2023-07-29T02:13:59+08:00</updated><author><name>zhiliao</name></author><id>tag:None,2023-07-29:/posts/2023/07/29/gdb.html</id><summary type="html">&lt;h1&gt;获取进程的coredump （内核转储）&lt;/h1&gt;
&lt;h2&gt;启用内核转储&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;查看coredump功能是否有效&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ulimit&lt;/code&gt;和&lt;code&gt;ulimit -c&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;开启内核转储&lt;/td&gt;
&lt;td&gt;ulimit -c unlimited&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;设置coredump大小上限&lt;/td&gt;
&lt;td&gt;ulimit …&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</summary><content type="html">&lt;h1&gt;获取进程的coredump （内核转储）&lt;/h1&gt;
&lt;h2&gt;启用内核转储&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;查看coredump功能是否有效&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ulimit&lt;/code&gt;和&lt;code&gt;ulimit -c&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;开启内核转储&lt;/td&gt;
&lt;td&gt;ulimit -c unlimited&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;设置coredump大小上限&lt;/td&gt;
&lt;td&gt;ulimit -c 大小（Byte）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;gdb调试core文件&lt;/td&gt;
&lt;td&gt;gdb -c core.xxxx  ./a.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;检查是否是core文件&lt;/td&gt;
&lt;td&gt;file xxx输出core file&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;在专用目录中生成coredump&lt;/h2&gt;
&lt;p&gt;coredump保存位置的完整路径可以通过sysctl变量&lt;code&gt;kernel.core_pattern&lt;/code&gt;设置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;临时修改使用&lt;code&gt;echo /var/core/%t-%e-%p-%c.core &amp;gt; /proc/sys/kernel/core_pattern&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;或者&lt;code&gt;/etc/sysctl.conf&lt;/code&gt;中设置&lt;code&gt;kernel.core_pattern=/var/core/%t-%e-%p-%c.core&lt;/code&gt;。然后sysctl -p`让配置生效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;kernel.core_uses_pid=1 作用是在生成的core文件名字结尾添加&lt;code&gt;.PID&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;kernel.core_uses_pid=0则不添加。&lt;/p&gt;
&lt;h3&gt;kernel.core_pattern中可以设置的格式符&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;格式符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;%%&lt;/td&gt;
&lt;td&gt;%字符本身&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%p&lt;/td&gt;
&lt;td&gt;进程PID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%u&lt;/td&gt;
&lt;td&gt;进程的真实用户ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%g&lt;/td&gt;
&lt;td&gt;进程的真实组ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%s&lt;/td&gt;
&lt;td&gt;引发coredump的信号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%t&lt;/td&gt;
&lt;td&gt;转储时间戳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%h&lt;/td&gt;
&lt;td&gt;主机名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%e&lt;/td&gt;
&lt;td&gt;可执行文件名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%c&lt;/td&gt;
&lt;td&gt;转储文件大小上限&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;使用用户程序辅助自动压缩coredump文件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;kernel.core_pattern&lt;/code&gt;中可以加入管道符，管道符后面写程序名。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;echo "|/usr/local/sbin/core_helper %t %e %p %c" &amp;gt; /proc/sys/kernel/core_pattern&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;或者 sudo sysctl -w 'kernel.core_pattern=%t-%e-%p-%c.core'&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;或者 /etc/sysctl.conf&lt;code&gt;中设置&lt;/code&gt;kernel.core_pattern=|/usr/local/sbin/core_helper %t %e %p %c&lt;code&gt;。然后sysctl -p&lt;/code&gt;让配置生效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;core_heaper 文件内容很简单：&lt;/p&gt;
&lt;p&gt;cat core_heaper&lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;

&lt;span class="nb"&gt;exec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;gzip&lt;span class="w"&gt; &lt;/span&gt;-&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;/var/core/&lt;span class="nv"&gt;$1&lt;/span&gt;-&lt;span class="nv"&gt;$2&lt;/span&gt;-&lt;span class="nv"&gt;$3&lt;/span&gt;-&lt;span class="nv"&gt;$4&lt;/span&gt;.core
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;启用整个系统的coredump功能&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 service 文件 &lt;code&gt;[Service]&lt;/code&gt;中添加LimitCORE=infinity， 不制service服务core文件的大小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使SUID 程序也转储&lt;code&gt;sysctl -w 'fs.suid_dumpable=1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;systemd用户的coredumpctl&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装systemd-coredump &amp;amp;&amp;amp; reboot&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sudo coredumpctl list 列出当前corefile 文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sudo coredumpctl list 'smplayer' | tail -n 5&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/var/lib/systemd/coredump/ 这是corefile 默认保存位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;coredumpctl -o core dump PID # 获得转储信息，输出到文件core 中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;man systemd-coredump; man core 查看手册&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;利用内核转储掩码排除共享内存&lt;/h2&gt;
&lt;p&gt;有些程序会使用多个进程和几个G的共享内存，coredmp时间过长。&lt;/p&gt;
&lt;p&gt;在使用各个共享内存的进程中，共享内存的内容是相同的，没必要所有进程都转储共享内存。这种应用程序应当设置成只在某个进程中转储共享内存，其他进程无须转储。&lt;/p&gt;
&lt;p&gt;设置方法：echo 1 &amp;gt; &lt;code&gt;/proc/&amp;lt;PID&amp;gt;/coredump_filter&lt;/code&gt; （16进制）&lt;/p&gt;
&lt;p&gt;比特掩码对应的内存类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(bit 0) anonymous private memory（匿名私有内存段）&lt;/li&gt;
&lt;li&gt;(bit 1) anonymous shared memory（匿名共享内存段）&lt;/li&gt;
&lt;li&gt;(bit 2) file-backed private memory（file-backed 私有内存段）&lt;/li&gt;
&lt;li&gt;(bit 3) file-backed shared memory（file-bakced 共享内存段）&lt;/li&gt;
&lt;li&gt;(bit 4) ELF header pages in file-backed private memory areas（ELF 文件映射，只有在bit 2 复位的时候才起作用）&lt;/li&gt;
&lt;li&gt;(bit 5) hugetlb private memory（大页面私有内存）&lt;/li&gt;
&lt;li&gt;(bit 6) hugetlb shared memory（大页面共享内存）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认的coredump_filter 的值一般是0x33&lt;/p&gt;
&lt;p&gt;要跳过所有的共享内存，可以设置为 &lt;code&gt;echo 1 &amp;gt; /proc//coredump_filter&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;调试器的基本使用方法&lt;/h1&gt;</content><category term="programming"></category><category term="debug"></category><category term="programming"></category><category term="linux"></category><category term="C"></category></entry><entry><title>解决linux下Qt creator不显示qDebug输出</title><link href="/posts/2022/07/04/qt-creator-qDebug.html" rel="alternate"></link><published>2022-07-04T18:50:55+08:00</published><updated>2023-02-21T09:52:21+08:00</updated><author><name>zhiliao</name></author><id>tag:None,2022-07-04:/posts/2022/07/04/qt-creator-qDebug.html</id><summary type="html">&lt;p&gt;linux下Qt creator 不显示qDebug输出， 可以在qtcreator的.desktop文件添加环境变量。
&lt;code&gt;env QT_ASSUME_STDERR_HAS_CONSOLE=1 qtcreator&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;源代码原编写于Windows系统中，迁移到Linux上后使 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;linux下Qt creator 不显示qDebug输出， 可以在qtcreator的.desktop文件添加环境变量。
&lt;code&gt;env QT_ASSUME_STDERR_HAS_CONSOLE=1 qtcreator&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;源代码原编写于Windows系统中，迁移到Linux上后使用同一个qt工程文件进行编译，程序可以运行，但是无法输出QDebug信息。可能是Linux默认禁用了Qt的调试信息处理程序。&lt;/p&gt;
&lt;p&gt;解决方案如下：&lt;/p&gt;
&lt;p&gt;在主程序源代码添加&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;QLoggingCategory::defaultCategory()-&amp;gt;setEnabled(QtDebugMsg, true);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相关的讨论如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://forum.qt.io/topic/81430/unable-to-see-the-qdebug-messages-on-console/15&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果采用另一种方法，即在终端设置环境变量&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;export QT_LOGGING_RULES="*.debug=true"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么会有大量诸如鼠标事件、界面状态等不属于QDebug输出信息之外的内容打印在终端上。&lt;/p&gt;</content><category term="programming"></category><category term="programming"></category><category term="Qt"></category></entry><entry><title>统计代码行数cloc (count lines of code)</title><link href="/posts/2022/06/29/cloc.html" rel="alternate"></link><published>2022-06-29T17:17:17+08:00</published><updated>2022-07-26T18:17:52+08:00</updated><author><name>zhiliao</name></author><id>tag:None,2022-06-29:/posts/2022/06/29/cloc.html</id><content type="html">&lt;p&gt;统计代码行数可以使用cloc，gocloc&lt;/p&gt;
&lt;h4&gt;使用cloc&lt;/h4&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;apt&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;cloc
cloc&lt;span class="w"&gt; &lt;/span&gt;.
cloc&lt;span class="w"&gt; &lt;/span&gt;xxx-source.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;使用gocloc&lt;/h4&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# https://github.com/hhatto/gocloc&lt;/span&gt;
gocloc&lt;span class="w"&gt; &lt;/span&gt;.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="programming"></category><category term="programming"></category></entry><entry><title>关于Qt</title><link href="/posts/2022/04/11/about-qt.html" rel="alternate"></link><published>2022-04-11T14:48:07+08:00</published><updated>2023-02-21T09:52:21+08:00</updated><author><name>zhiliao</name></author><id>tag:None,2022-04-11:/posts/2022/04/11/about-qt.html</id><content type="html">&lt;p&gt;QString转char*的正确方法&lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;QString&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toLocal8Bit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;constData&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;QString&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toUtf8&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;constData&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="programming"></category><category term="programming"></category></entry><entry><title>C++书籍推荐</title><link href="/posts/2015/01/01/cpp-books.html" rel="alternate"></link><published>2015-01-01T00:00:00+08:00</published><updated>2023-02-21T09:52:21+08:00</updated><author><name>zhiliao</name></author><id>tag:None,2015-01-01:/posts/2015/01/01/cpp-books.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;C++Primer 5th 中文版 (no Plus)&lt;/li&gt;
&lt;li&gt;Inside C++ Object Model&lt;/li&gt;
&lt;li&gt;The Design and Evolution of C++&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这三本就够用了，可以应付绝大多数的工作&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下面是转载的在博客上看到的一 …&lt;/p&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;C++Primer 5th 中文版 (no Plus)&lt;/li&gt;
&lt;li&gt;Inside C++ Object Model&lt;/li&gt;
&lt;li&gt;The Design and Evolution of C++&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这三本就够用了，可以应付绝大多数的工作&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下面是转载的在博客上看到的一个C++书籍阅读清单，可以参考下：&lt;/p&gt;
&lt;h2&gt;阶段 1&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;《Essential C++》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是一本内容不多但很实用的C++入门书籍，强调快速上手与理解C++编程。本书主要围绕一系列逐渐复杂的程序问题，以及用以解决这些问题的语言特性展开讲解。你不只学到C++的函数和结构，也会学习到它们的设计目的和基本原理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《C++ Primer》（不是 plus）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本书对C++基本概念、技术、以及现代C++编程风格进行了全面而且权威的阐述，是C++初学者的最佳指南；本书可以帮助你编写实用的程序，而无需首先精通每个语言细节。对于中高级程序员，本书也是不可或缺的参考书。&lt;/p&gt;
&lt;h2&gt;阶段 2&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;《Effective C++》和《More effective C++》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作者是Scott Meyers。你应该熟读它们，并清楚地理解每个项目。该书围绕55条准则，每一条都介绍了一个可让你写出更好的C++程序代码的方法，并以特别设计过的例子详加讨论。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Exceptional C++（C++编程剖析）》和《More exceptional C++》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两本书中都包含了40个C++编程问题，这些问题会让你磨练自己的技能，最终成为优秀的C++程序员。这些问题是Herb Sutter精心挑选，与ISO/ANSI C++官方标准相一致，帮助程序员在设计、架构和编码过程中保持良好的风格，从而使编写的C++软件更健壮、更高效。&lt;/p&gt;
&lt;h2&gt;阶段 3&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;《Inside the C++ object model（深度探索C++对象模型）》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本书专注于C++面向对象程序设计的底层机制，包括结构式语意、临时性对象的生成、封装、继承，以及虚拟——虚拟函数和虚拟继承，帮助你理解程序的底层实现，以便写出更高效的代码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《The design and evolution of C++（C++语言的设计与演化）》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本书作者也是C++语言的设计者Bjarne Stroustrup，作者在书中综合性地介绍了C++的发展历史，C++中各种重要机制的本质意义和设计背景，这些机制的基本用途和使用方法，讨论了C++所适合的应用领域及其未来的发展前景，既没有忽略关键性的详情，又没有过多地陷入技术细节。&lt;/p&gt;
&lt;h2&gt;阶段 4&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;《The C++ standard library（C++标准程序库）》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是标准模板库字典，你可以在本书中找到STL相关的一切知识。本书焦点放在标准模板库、检查容器、迭代器、函数对象和STL算法上。每一个元素都有深刻的呈现，包括其介绍、设计、运用实例、细节解说、陷阱、意想不到的危险，以及相关类别和函数等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Effective STL》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是Scott Meyers的第三本C++专著，也是学习STL最权威的书籍。作者对书中的50个指导方针都作了详尽的分析，并配以示例。通过这些规则，C++开发者可以最大限度地使用STL。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Generic programming and the STL（泛型编程与STL）》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本书阐述了泛型程序设计的核心理念：concepts（概念）、modeling（模型）和refinement（改善），并为你展示这些观念如何导出STL的基础概念：iterators（迭代器）、containers（容器）和function objects（函数对象）。按照本书所述，你可以把STL想象成一个由concepts组成的library，你将学习到STL正式结构并理解其强大的优势。&lt;/p&gt;
&lt;h2&gt;阶段 5&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;《Exceptional C++ style》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作者为Herb Sutter。本书同样提出了40个C++风格相关的问题，对一些至关重要的C++细节和相互关系提出了新的见解，为当今的关键C++编程技术（如泛型编程、STL、异常安全等）提供了新的策略，帮助开发者在开销与功能之间、优雅与可维护性之间、灵活性与过分灵活之间寻找完美的平衡点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《C++ template》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是一本关于C++模板的完整的参考手册和教程，它强调模板的使用实践，包含了现实世界中的例子。每个C++程序员都应该好好读一读这本书。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Modern C++ design（现代C++设计）》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作者Andrei Alexandrescu为C++程序员打开了一个新的局面。本书提供了一些针对软件设计的前沿方法，如联合设计模式、泛型编程，使程序员可以编写有表现力的、灵活的、高度可重用的代码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Thinking in C++（C++编程思想）》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ 领域权威著作，介绍了C++实用的编程技术和最佳的实践方法。&lt;/p&gt;</content><category term="programming"></category><category term="programming"></category><category term="C++"></category><category term="book"></category></entry><entry><title>C语言深度解剖</title><link href="/posts/2014/08/06/programming-C.html" rel="alternate"></link><published>2014-08-06T00:00:00+08:00</published><updated>2023-02-21T09:52:21+08:00</updated><author><name>zhiliao</name></author><id>tag:None,2014-08-06:/posts/2014/08/06/programming-C.html</id><summary type="html">&lt;p&gt;register 变量必须是一个单个的值，并且其长度应小于或等于整型的长度。 而且 register 变量可能不存放在内存中，所以不能用取址运 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;register 变量必须是一个单个的值，并且其长度应小于或等于整型的长度。 而且 register 变量可能不存放在内存中，所以不能用取址运算符“&amp;amp;”来获取 register 变量的地址。
 
static 静态全局变量，作用域仅限于变量被定义的文件中，其他文件即使用 extern 声明也没法
使用他。准确地说作用域是从定义之处开始，到文件结尾处结束，在定义之处前面的那些
代码行也不能使用它。想要使用就得在前面再加 extern ***。恶心吧？要想不恶心，很简单，
直接在文件顶端定义不就得了。&lt;/p&gt;
&lt;p&gt;静态局部变量，在函数体里面定义的，就只能在这个函数里用了，同一个文档中的其他
函数也用不了。由于被 static 修饰的变量总是存在内存的静态区，所以即使这个函数运行结
束，这个静态变量的值还是不会被销毁，函数下次使用时仍然能用到这个值。&lt;/p&gt;
&lt;p&gt;函数前加 static 使得函数成为静态函数。但此处“static”的含义不是指存储方式，而是指对函数的作用域仅局限于本文件(所以又称内部函数)。使用内部函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其它文件中的函数同名。
 
关键字 static 有着不寻常的历史。起初，在 C 中引入关键字 static 是为了表示退出一个
块后仍然存在的局部变量。随后，static 在 C 中有了第二种含义：用来表示不能被其它文件访问的全局变量和函数。为了避免引入新的关键字，所以仍使用 static 关键字来表示这第二种含义。
 
 
对在多个文件之间共同使用的全局变量或函数要加范围限定符(建议使用模块名
(缩写)作为范围限定符)。(GUI_ ，etc)
 
 特别注意的就是 1（数字 1）和 l（小写字母 l）之间，0（数字 0）和 o
（小写字母 o）之间的区别&lt;/p&gt;
&lt;p&gt;所有宏定义、枚举常数、只读变量全用大写字母命名，用下划线分割单词。&lt;/p&gt;
&lt;p&gt;float 变量与“零值”进行比较的 if 语句怎么写？
  
同样的也不要在很大的浮点数和很小的浮点数之间进行运算
 
一般来说习惯上用 n,m,i,j,k 等表示 int 类型的变量；c，ch 等表示字符类型变量；a 等表
示数组；p 等表示指针。当然这仅仅是一般习惯，除了 i,j,k 等可以用来表示循环变量外，别
的字符变量名尽量不要使用。 &lt;/p&gt;
&lt;p&gt;程序中不得出现仅靠大小写区分的相似的标识符。&lt;/p&gt;
&lt;p&gt;定义变量的同时千万千万别忘了初始化。定义变量时编译器并不一定清空了 这块内存，它的值可能是无效的数据。&lt;/p&gt;
&lt;p&gt;case 后面只能是整型或字符型的常量或常量表达式（想想字符型数据在内存里
是怎么存的
 
有时候，你只剩下了最后一种情况需要处理，于是就决定把这种情况用 default 子句来
处理。这样也许会让你偷懒少敲几个字符，但是这却很不明智。这样将失去 case 语句的标
号所提供的自说明功能，而且也丧失了使用 default 子句处理错误情况的能力。
 
 
在多重循环中，如果有可能，应当将最长的循环放在最内层，最短的循环放
在最外层，以减少 CPU 跨切循环层的次数
 
长循环在最内层，效率高&lt;/p&gt;
&lt;p&gt;当循环嵌套超过 3 层，程序员对循环的理解能力会极大的降低。&lt;/p&gt;
&lt;p&gt;void *则不同，任何类型的指针都可以直接赋值给它，无需进行强制类型转换：&lt;/p&gt;
&lt;p&gt;在 C 语言中，凡不加返回值类型限定的函数，就会被编译器作为返回整型值处理&lt;/p&gt;
&lt;p&gt;在 C 语言中，可以给无参数的函数传送任意类型的参数，
但是在 C++编译器中编译同样的代码则会出错
无论在 C 还是 C++中，若函数不接受任何参数，一定要指明参数为 void。
 &lt;/p&gt;
&lt;p&gt;要求余数与被除数的正负号相同&lt;/p&gt;</content><category term="programming"></category><category term="programming"></category><category term="C"></category></entry><entry><title>apue读书笔记</title><link href="/posts/2014/06/23/apue-note.html" rel="alternate"></link><published>2014-06-23T00:00:00+08:00</published><updated>2023-02-21T09:52:21+08:00</updated><author><name>zhiliao</name></author><id>tag:None,2014-06-23:/posts/2014/06/23/apue-note.html</id><summary type="html">&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;打印出错信息：
Strerror  perror
一个unix惯例是把argv[0]作为参数传递给perror
好处是当用管道连接多个程序时，能分清错误是哪一个产生 …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;打印出错信息：
Strerror  perror
一个unix惯例是把argv[0]作为参数传递给perror
好处是当用管道连接多个程序时，能分清错误是哪一个产生的。

可以free（NULL）

 fork  ，pthread create 之前要fflsh(null) 刷新缓存区
否则可能会输出两次
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="programming"></category><category term="programming"></category><category term="python"></category></entry><entry><title>C语言零长数组</title><link href="/posts/2014/03/23/zero-length-array.html" rel="alternate"></link><published>2014-03-23T18:28:00+08:00</published><updated>2023-02-21T09:52:21+08:00</updated><author><name>zhiliao</name></author><id>tag:None,2014-03-23:/posts/2014/03/23/zero-length-array.html</id><summary type="html">&lt;p&gt;前言：计算机语言是编译器和程序员交流的依据和规范，GNU C是GCC特有的功能，在Linux内核中被广泛应用。&lt;/p&gt;
&lt;p&gt;帮助文档：http://gcc.gnu.org …&lt;/p&gt;</summary><content type="html">&lt;p&gt;前言：计算机语言是编译器和程序员交流的依据和规范，GNU C是GCC特有的功能，在Linux内核中被广泛应用。&lt;/p&gt;
&lt;p&gt;帮助文档：http://gcc.gnu.org/onlinedocs/gcc-4.6.2/gcc/C-Extensions.html#C-Extensions&lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;int *p;
p=(int[]){99};
GCC 临时变量
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;1、零长数组&lt;/h2&gt;
&lt;p&gt;GNU C允许声明长度为零的数组，但它只能被用于结构体的最后一个成员。&lt;/p&gt;
&lt;p&gt;举例，如清单1： &lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include &lt;/span&gt;
&lt;span class="cp"&gt;#include &lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;letter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;thisline&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;thisline&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;thisline&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;letter&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sizeof(struct line) = %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;line&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;thisline&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%c &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;thisline&lt;/span&gt;&lt;span class="o"&gt;-&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;例子输出结果： &lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sizeof(struct line) = 4  
A B C D E F G H I
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如例子中的第6行，contents就是一个零长数组，在sizeof看来它所占的空间为零。&lt;/p&gt;
&lt;h2&gt;在ISO C99中，使用变长数组也可以实现同样的功能，如清单2：&lt;/h2&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="n"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="nc"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="err"&gt;[]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;thisline&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;4&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;5&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;sizeof(struct line) = %d\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;sizeof(thisline) = %d\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;thisline&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;thislinelengthispan&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;%c &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;thisline&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;例子输出结果： &lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sizeof(struct line) = 4  
sizeof(thisline) = 4  
1 2 3 4 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;变长数组是不完全数据类型，不能使用sizeof获得它的大小。&lt;/p&gt;
&lt;p&gt;注意，此结构体的变量必须在函数外定义和初始化，否则会报错： &lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;non&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;initialization&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;of&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;flexible&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;near&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;initialization&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;thisline&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;不能使用这样的形式：&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;

&lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mystruct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="n"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;[];&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="o"&gt;};&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;否则会报错：&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;flexible&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;otherwise&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;struct&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2、变长数组&lt;/h3&gt;
&lt;p&gt;在支持变长数组之前，C语言数组的大小是在声明时确定的（下标是一个常量表达式）并一直保持不变。所谓变长数组就是指数组的大小可以在运行时指定，如清单3： &lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;scanf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;%d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;sizeof(arr[%d]) = %d\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;例子输出结果： &lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sizeof(arr[6]) = 24 //输入数字6
sizeof(arr[9]) = 36 //输入数字9
    输入不同的值，数组的大小随之改变。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;变长数组作为参数进行传递的例子，如清单4： &lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;total&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;numispan&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;total&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;total&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="err"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;a[] total value: %d\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;b[] total value: %d\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;例子输出结果：&lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;a[] total value: 10  
b[] total value: 45  
    函数sum形参中的arr可以匹配任意的一维整型数组。
    注意，num一定要声明在变长数组arr之前。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="programming"></category><category term="programming"></category><category term="C"></category></entry></feed>