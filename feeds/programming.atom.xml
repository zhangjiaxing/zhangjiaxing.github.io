<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>cat writebug.cn/history - programming</title><link href="/" rel="alternate"></link><link href="/feeds/feeds/programming.atom.xml" rel="self"></link><id>/</id><updated>2023-08-15T22:15:02+08:00</updated><subtitle>一个开发者的技术博客。</subtitle><entry><title>java入门精粹</title><link href="/posts/2023/08/15/learn-java.html" rel="alternate"></link><published>2023-08-15T00:52:44+08:00</published><updated>2023-08-15T22:15:02+08:00</updated><author><name>zhiliao</name></author><id>tag:None,2023-08-15:/posts/2023/08/15/learn-java.html</id><summary type="html">&lt;h2&gt;第一章 java开发入门&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;java类只支持单继承，但接口之间支持多继承。&lt;/li&gt;
&lt;li&gt;jdk包括java编译器，java运行时，java文档工具，java打包工具等。&lt;/li&gt;
&lt;li&gt;jdk安 …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;h2&gt;第一章 java开发入门&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;java类只支持单继承，但接口之间支持多继承。&lt;/li&gt;
&lt;li&gt;jdk包括java编译器，java运行时，java文档工具，java打包工具等。&lt;/li&gt;
&lt;li&gt;jdk安装目录内的db目录，这是java实现的开源数据库javaDB,支持jdbc。&lt;/li&gt;
&lt;li&gt;java源文件扩展名是.java, 编译后的字节码文件扩展名是.class。&lt;/li&gt;
&lt;li&gt;HelloWrold.java&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;HelloWorld&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello world&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;使用javac HelloWrold.java编译。生成HelloWorld.class。javac参数是文件名。&lt;/li&gt;
&lt;li&gt;java HelloWorld运行。java参数是类名。&lt;/li&gt;
&lt;li&gt;java相关环境变量。PATH环境变量用来寻找java和javac等。CLASSPATH变量是java虚拟机用来加载字节码文件的路径。如果CLASSPATH没有设置，默认就是&lt;code&gt;.(当前目录)&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;第二章 java编程基础&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;java代码的基本格式&lt;code&gt;修饰符 class 类名 { 代码 }&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;java中一个字符串中间不能分在两行写， 需要分成两个字符串用&lt;code&gt;+&lt;/code&gt;连接起来。&lt;/li&gt;
&lt;li&gt;java中的注释包括 单行注释&lt;code&gt;//&lt;/code&gt;， 多行注释&lt;code&gt;/*注释内容*/&lt;/code&gt;，文档注释&lt;code&gt;/**注释内容*/&lt;/code&gt;。javadoc命令用来把文档注释提取来生成帮助文档。&lt;/li&gt;
&lt;li&gt;java中的标识符可以包括大小写字母，数字，下划线_，和美元符号$，不能以数字开头，且不能是java关键字。&lt;/li&gt;
&lt;li&gt;建议的java命名规范&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="mf"&gt;1.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;包名所有字母小写&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
&lt;span class="mf"&gt;2.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;类名和接口名每个单词首字母大写&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
&lt;span class="mf"&gt;3.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;常量名所有字母大写&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="n"&gt;单词间用下划线连接&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
&lt;span class="mf"&gt;4.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;变量名和方法名第一个单词首字母小写&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="n"&gt;从第二个单词开始首字母大写&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;java关键字&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;abstract&lt;/span&gt; &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt; &lt;span class="n"&gt;byte&lt;/span&gt; &lt;span class="n"&gt;case&lt;/span&gt; 
&lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;continue&lt;/span&gt; 
&lt;span class="n"&gt;default&lt;/span&gt; &lt;span class="n"&gt;do&lt;/span&gt; &lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;extends&lt;/span&gt; 
&lt;span class="n"&gt;final&lt;/span&gt; &lt;span class="k"&gt;finally&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;goto&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;instanceof&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;
&lt;span class="n"&gt;interface&lt;/span&gt; &lt;span class="n"&gt;long&lt;/span&gt; &lt;span class="n"&gt;native&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt;
&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;protected&lt;/span&gt; &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;short&lt;/span&gt;
&lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="n"&gt;strictfp&lt;/span&gt; &lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="n"&gt;switch&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt;
&lt;span class="n"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;transient&lt;/span&gt; &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt;
&lt;span class="n"&gt;volatile&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;synchronized&lt;/span&gt;
&lt;span class="n"&gt;所有关键字都是小写的&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;java中的整形常量支持二进制八进制十进制十六进制表示，二进制八进制十六进制分别以&lt;code&gt;0b/0B，0, 0x/0X&lt;/code&gt;开头。&lt;/li&gt;
&lt;li&gt;java浮点型常量，单精度后面用F/f结尾，双精度后面用D/d结尾。d可以不写，默认是双精度。&lt;/li&gt;
&lt;li&gt;java字符常量，要用英文单引号引起来，java使用unicode字符集，支持转义字符，支持 '\u0000'。&lt;/li&gt;
&lt;li&gt;java布尔常量包括true 和false。&lt;/li&gt;
&lt;li&gt;null类型常量只有一个值null,表示对象的引用是空。&lt;/li&gt;
&lt;li&gt;十进制转二进制是一个不断除以2区余数的过程。把要转换的数除以2,得到商和余数，把商继续除以2,直到商为0.&lt;/li&gt;
&lt;li&gt;二进制转十进制要从右到左用二进制位上的每个数乘以2的相应次方。&lt;/li&gt;
&lt;li&gt;java是强类型的语言。数据类型分成基本数据类型和引用数据类型。基本数据类型包括数值型（byte short int long float double）和字符型char，布尔型boolean。引用数据类型包括类class, 接口interface,数组，枚举enum,注解annotation。&lt;/li&gt;
&lt;li&gt;占用空间，（单位字节）byte类型 1，short 2, int 4, long 8. &lt;/li&gt;
&lt;li&gt;long型变量赋值时候右面的常量需要用L结尾。&lt;/li&gt;
&lt;li&gt;char类型变量占用2个字节。也可以把char赋值为0-65535之间的整数。&lt;/li&gt;
&lt;li&gt;boolean类型变量取值是true或false。&lt;/li&gt;
&lt;li&gt;强制类型转换&lt;code&gt;目标类型 变量 = (目标类型)值&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;变量在表达式中进行运算时，可能会发生自动类型转换，比如byte自动转换为int.&lt;/li&gt;
&lt;li&gt;java中的算术运算符包括&lt;code&gt;+（正号） -（负号）+ - * / % ++（前） ++（后）--（前）--（后）&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在进行除法运算时，当除数和被除数都是整数时，得到的结果也是整数，如果除法运算有小数参与，得到的结果是小数。&lt;/li&gt;
&lt;li&gt;在进行取模运算时，运算结果的正负取决于被模数（左边的数）的负号，与模数（右边的数）的符号无关。&lt;/li&gt;
&lt;li&gt;赋值运算符包括&lt;code&gt;= += -= *= /= %=&lt;/code&gt;。赋值运算符是有返回值的，可以用一条语句为多个变量赋值，比如&lt;code&gt;a=b=c=5;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用=为变量赋值时，在目标类型取值范围小于源类型时，比如将int变量赋值给short类型变量，需要显示的强制类型转换。用&lt;code&gt;+= -= *= /= %=&lt;/code&gt;为变量赋值时，强制类型转换会自动完成。&lt;/li&gt;
&lt;li&gt;比较运算符包括&lt;code&gt;== != &amp;lt; &amp;gt; &amp;lt;= &amp;gt;=&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;逻辑运算符用于对布尔类型的数据运算，结果也是布尔类型数据。包括&lt;code&gt;&amp;amp;  |  ^异或  !非  &amp;amp;&amp;amp;  ||&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&amp;amp;&amp;amp;是短路与，&amp;amp;不短路。||是短路或，|不短路。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt;表示异或。&lt;/li&gt;
&lt;li&gt;位运算符包括&lt;code&gt;&amp;amp;按位与  |按位或  ~去反  ^按位异或  &amp;lt;&amp;lt;左移  &amp;gt;&amp;gt;右移  &amp;gt;&amp;gt;&amp;gt;无符号右移&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;运算符优先级，&lt;code&gt;. []  ()&lt;/code&gt;优先级最高，赋值运算符优先级最低。&lt;/li&gt;
&lt;li&gt;选择结构语句支持&lt;code&gt;if(){}else{}&lt;/code&gt;，和C一样。支持&lt;code&gt;判断条件?表达式1:表达式2&lt;/code&gt;三元运算符。&lt;/li&gt;
&lt;li&gt;switch语句用法和C里面一样，但支持了String。&lt;/li&gt;
&lt;li&gt;while,do...while,for,break,continue用法和C中一样，但break和continue额外支持标记，多层循环时，用来跳出外层循环。用法是&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;itcast&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++){&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++){&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;itcast&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;//跳出外层循环&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;已经读完了page58/426。
后面的内容有机会补充&lt;/p&gt;</content><category term="programming"></category><category term="programming-language"></category><category term="java"></category></entry><entry><title>Tcl 和 expect教程</title><link href="/posts/2023/08/04/tcl-expect.html" rel="alternate"></link><published>2023-08-04T22:08:51+08:00</published><updated>2023-08-12T23:41:51+08:00</updated><author><name>zhiliao</name></author><id>tag:None,2023-08-04:/posts/2023/08/04/tcl-expect.html</id><summary type="html">&lt;h1&gt;expect&lt;/h1&gt;
&lt;p&gt;expect是用于命令行自动化交互的程序，相当于命令行版本的按键精灵。可以用来输入密码，操作程序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;expect基于Tcl/Tk实现，在expect …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h1&gt;expect&lt;/h1&gt;
&lt;p&gt;expect是用于命令行自动化交互的程序，相当于命令行版本的按键精灵。可以用来输入密码，操作程序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;expect基于Tcl/Tk实现，在expect脚本中使用Tcl语法和支持Tcl命令。&lt;/li&gt;
&lt;li&gt;通过添加Tk,你可以把命令行程序封装在Gui中。&lt;/li&gt;
&lt;li&gt;O'Reilly提供了一本关于Expect的书，书名为"Exploring Expect: A Tcl-Based Toolkit for Automating Interactive Applications", ISBN 1-56592-090-2.&lt;/li&gt;
&lt;li&gt;autoexpect 这是expect安装包提供的命令，支持录制expect脚本，录制好后稍微修改就能运行。&lt;/li&gt;
&lt;li&gt;shebang里面写&lt;code&gt;#!/usr/local/bin/expect −−&lt;/code&gt; --的作用是给脚本传递用户参数时避免被当成expect自身的参数。脚本可以从argv里面读取用户传递的参数。&lt;/li&gt;
&lt;li&gt;脚本参数在Tcl里面是&lt;code&gt;$argc $argv0 $argv&lt;/code&gt; $argc表示参数个数，$argv0相当于C语言中的argv[0], $argv是一个Tcl list, 使用&lt;code&gt;[lindex $argv index]&lt;/code&gt;来访问。&lt;/li&gt;
&lt;li&gt;Tcl 变量用&lt;code&gt;set 变量名 变量值&lt;/code&gt;定义。变量用&lt;code&gt;$变量名&lt;/code&gt;访问。&lt;/li&gt;
&lt;li&gt;Tcl if语句通常写法为 if { 条件 } { 条件执行内容 } elseif {条件} {执行内容} else {执行内容}&lt;/li&gt;
&lt;li&gt;Tcl while语句通常写法为 while { 条件} { 循环体 }&lt;/li&gt;
&lt;li&gt;Tcl foreach语句通常写法为 &lt;code&gt;foreach 变量名 列表 { 执行内容 }&lt;/code&gt;。 while循环和foreach循环支持continue 和break。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;常用命令&lt;/span&gt;
&lt;span class="n"&gt;spawn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;启动要交互的应用程序&lt;/span&gt;
&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;用于向进程发送字符串&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="n"&gt;换行符或者回车符&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;确认输入&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
&lt;span class="n"&gt;send_user&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;用来打印输出&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;和tcl中puts差不多&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
&lt;span class="n"&gt;interact&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;允许用户交互&lt;/span&gt;
&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;退出expect脚本&lt;/span&gt;
&lt;span class="n"&gt;eof&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;expect执行结束&lt;/span&gt;
&lt;span class="n"&gt;exec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;执行程序&lt;/span&gt;
&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;暂停5秒&lt;/span&gt;


&lt;span class="n"&gt;expect&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;命令作用&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="n"&gt;等待&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="n"&gt;直到其中一个模式与派生进程的输出匹配&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="n"&gt;超时&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="n"&gt;或者遇到文件结尾&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
&lt;span class="n"&gt;expect支持多分支匹配&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;用法如下&lt;/span&gt;
&lt;span class="n"&gt;expect&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pat1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;body1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;patn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bodyn&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="n"&gt;exp_continue&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;在expect中多模式匹配就需要用到&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="n"&gt;允许expect本身继续执行&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="n"&gt;而不是按原样返回&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
&lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;定义expect超时的时间&lt;/span&gt;

&lt;span class="n"&gt;一个例子&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;
&lt;span class="cp"&gt;#!/usr/bin/expect&lt;/span&gt;
&lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;

&lt;span class="n"&gt;expect&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nl"&gt;Password&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;send_user&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;password (for $user) on $host: &amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;expect_user&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;(.*)&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;send_user&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;$expect_out(1,string)&lt;/span&gt;&lt;span class="se"&gt;\r&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;exp_continue&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;incorrect&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;send_user&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;invalid password or account&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;send_user&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;connection to $host timed out&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;eof&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;send_user&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;\
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;connection to host failed: $expect_out(buffer)&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;$prompt&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1&gt;Tcl语言学习&lt;/h1&gt;
&lt;h2&gt;Tcl语言介绍&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;最早称为“工具命令语言” Tool Command Language&lt;/li&gt;
&lt;li&gt;跨平台&lt;/li&gt;
&lt;li&gt;容易学习&lt;/li&gt;
&lt;li&gt;方便图形界面编程（Tk）&lt;/li&gt;
&lt;li&gt;既可以交互式执行脚本，也可以内嵌到其他程序中&lt;/li&gt;
&lt;li&gt;支持事件循环&lt;/li&gt;
&lt;li&gt;支持package&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;语法（man Tcl）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;分号和换行分隔命令，命令和参数之间用空格/tab分割。&lt;code&gt;#&lt;/code&gt;是单行注释，注释字符只有出现在一个命令开始时才有意义。&lt;/li&gt;
&lt;li&gt;命令求值过程：1. 解释器把命令分解成字worlds, 完成替换。2. 第一个字是执行过程，后面的字作为执行过程的参数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;""&lt;/code&gt;双引号内的内容表示一个“字”， 在引号之间的字符上会进行命令替换、变量替换、和反斜杠替换。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{}&lt;/code&gt;花括号内的内容表示一个“字”，花括号可以嵌套， 花括号会按照层级进行匹配。在花括号之间的字符上不进行替换，对分号、换行、右方括号、或白空格不做特殊的解释。（除了下面描述的反斜杠-换行替换之外）。字由外侧的花括号之间的字符精确的组成，不包括花括号自身。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt;方括号之间的内容Tcl进行命令替换。将递归调用Tcl解释器来把方括号中的字符作为一个Tcl脚本处理。脚本的结果将被替换到字方括号的位置。。在一个单一的字中可以有任意数目的命令替换。在由花括号包起来的字上不进行命令替换。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt;开始的字，Tck会进行变量替换。支持&lt;code&gt;$name&lt;/code&gt; &lt;code&gt;${name}&lt;/code&gt;, 替换数组时用&lt;code&gt;$name(index)&lt;/code&gt;。index的字符将被进行命令替换、变量替换、和反斜杠替换。&lt;code&gt;${name}&lt;/code&gt;可以包含除了右括号之外的任何字符。一个单一的字中可以有任意数目的变量替换。在由花括号包起来的字上不进行命令替换。&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;\&lt;/code&gt;反斜线进行转义。支持的转义字符有&lt;code&gt;\a \b \f \n \r \t \v \{ \} \\&lt;/code&gt;。&lt;code&gt;\&amp;lt;newline&amp;gt;whiteSpace&lt;/code&gt;用来替换换行+空格的，整体会被替换为一个空格。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\&lt;/code&gt;转义符号也支持unicode。&lt;code&gt;\ooo&lt;/code&gt; o是最多三个的8进制字符。&lt;code&gt;\xhh&lt;/code&gt; h是最多2个的16进制字符。&lt;code&gt;\uhhhh&lt;/code&gt; 最多4个的16进制字符。这些会被替换成unicode字符。除了&lt;code&gt;\&amp;lt;newline&amp;gt;whiteSpace&lt;/code&gt;，其他在由花括号包起来的字上不进行反斜杠替换。&lt;/li&gt;
&lt;li&gt;替换不影响一个命令的字边界。例如，即使变量的值包含空格，在变量替换期间变量的整个的值成为一个单一的字的一部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;备注&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;有个交互式解释器tclsh, 可以作为操作系统的shell使用&lt;/li&gt;
&lt;li&gt;没有数字类型，可以认为只有Tck中的一切都是字worlds构成。&lt;/li&gt;
&lt;li&gt;三种替换，分别是命令替换[]， 变量替换$，反斜线替换。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;自己瞎点评Tcl语言&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;函数传参和bash脚本一样，在进入函数前要把列表先展开，然后传递给命令，注定了效率低。&lt;/li&gt;
&lt;li&gt;如果没有在参数中展开的变量，比如array这种不支持直接展开的，要在函数内用upvar命令获取上层函数的变量。使用起来不太方便。&lt;/li&gt;
&lt;li&gt;不支持类型，一切都是token list，这个特点也让Tcl不能很方便的操作json等带类型的复杂数据结构。比如json里面的"100"是个字符串，转到Tcl里面类型就会丢失和100没区别。而python的json和dict互转就非常自然。&lt;/li&gt;
&lt;li&gt;从语言定位来看, Tcl 应该是介于bash script和lua/python之间的编程语言。字符串处理和数据运算比bash方便，调用系统命令方便，也带json数据库网络图形界面支持，适合用来写不太复杂，但又要操作数据或者需要gui的脚本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;常用命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;查看Tcl命令帮助可以&lt;code&gt;man 3Tcl 命令&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set 变量 值&lt;/code&gt;能够设置变量的值, 无需声明变量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unset 变量&lt;/code&gt;移除变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;puts WORLDS&lt;/code&gt; 显示，支持worlds中支持变量替换&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;条件执行和循环&lt;/h3&gt;
&lt;p&gt;if根据条件执行脚本。使用方法&lt;code&gt;if expr1 ?then? body1 elseif expr2 ?then? body2 elseif ... ?else? ?bodyN?&lt;/code&gt;。前后有问号的worlds是可以省略的。
if命令把expr1作为一个表达式来求值(用与expr求值它的参数相同的方式)。这个表达式的值必须式一个boolean值(一个数值值，这里0是假而任何其他数值都是真；或者是一个字符串值，比如true或yes是真 而false或no是假)；如果它是真通过把body1传递给Tcl解释器来执行它。
由于expr1 和 body1是一个表达式（worlds）, 所以一般要用{}或双引号引起来传递给if。不能乱换行，换行需要在&lt;code&gt;{或者"&lt;/code&gt;中。
then和else是可选的“噪音词”用来使命令易读。命令的返回值是被执行的那个脚本的返回值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;expr命令会首先用空格连接所有参数，在命令提换和变量替换后，计算表达式的值，和C语言差不多。 详见&lt;code&gt;man 3tcl expr&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;zhangsan&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;puts&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;nihao
&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;puts&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;hello
&lt;span class="k"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="nv"&gt;$age&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;    puts &amp;gt;=14&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;    puts &amp;lt;14&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;和&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;之间要有空格&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;否则会被Tcl当作一个整体&lt;span class="err"&gt;。&lt;/span&gt;
&lt;span class="nv"&gt;第一个if更易读&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
&lt;span class="nv"&gt;这两个区别是用花括号时候&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;$name&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;是在if外面被求值&lt;span class="err"&gt;。&lt;/span&gt;用双引号则&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;$age&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;在if命令里面被求值&lt;span class="err"&gt;（&lt;/span&gt;替换&lt;span class="err"&gt;）。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;while test body&lt;/code&gt;循环。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;其他流程控制&lt;/h3&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nv"&gt;foreach&lt;/span&gt;
&lt;span class="nv"&gt;switch&lt;/span&gt;

&lt;span class="k"&gt;continue&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;和&lt;span class="nv"&gt;break&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;和&lt;span class="nv"&gt;C&lt;/span&gt;语言中一样。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;字符串处理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;string命令用于字符串处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;list （man 3tcl list）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;list ?arg arg ...?&lt;/code&gt;这个命令返回由所有arg组成的一个列表。如果未指定arg 则返回一个空串。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;list  直接用原始参数来工作。例如，命令
    list a b {c d e} {f {g h}}
将返回
    a b {c d e} {f {g h}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;创建list变量的三种方法&lt;code&gt;set arr "1 2 3 4"&lt;/code&gt; &lt;code&gt;set arr {1 2 3 4}&lt;/code&gt; &lt;code&gt;set arr [list 1 2 3 4]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;list相关命令用l开头，可以在tclsh中输入l,查询list相关命令有哪些。&lt;code&gt;lappend lassign lindex linsert list llength lmap load lrange lrepeat lreplace lreverse lsearch lset lsort&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;llength 获取元素个数字符串&lt;/li&gt;
&lt;li&gt;lrange 截取子list&lt;/li&gt;
&lt;li&gt;lindex 根据index获取元素&lt;/li&gt;
&lt;li&gt;linsert 插入&lt;/li&gt;
&lt;li&gt;lset 修改指定位置的元素&lt;/li&gt;
&lt;li&gt;lreplace 相当于字符串的replace，可以替换为0个到多个元素。&lt;/li&gt;
&lt;li&gt;lconat 合并list&lt;/li&gt;
&lt;li&gt;lappend 追加list元素&lt;/li&gt;
&lt;li&gt;lrepeat 把value重复N次，得到一个list&lt;/li&gt;
&lt;li&gt;join 相当于字符串的join。&lt;/li&gt;
&lt;li&gt;split 把一个字符串分离成一个Tcl列表&lt;/li&gt;
&lt;li&gt;lsearch 搜索list,支持严格匹配，通配符，或者正则匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;array数组变量 （man 3tcl array）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;array set arrayName list&lt;/code&gt;创建array,list由偶数个元素组成，每个奇数元素被作为在array中被作为一个index对待。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array get arrayName ?pattern?&lt;/code&gt; 成对的返回数组元素列表。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array size arrayName&lt;/code&gt; 返回元素个数字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;glob partten&lt;/code&gt; 用于匹配文件路径，支持通配符&lt;code&gt;*?[char]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;创建命令（函数）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;proc name args body&lt;/code&gt;
args是一个列表，可以为空，每个元素指定一个参数。每个参数指定符也可以是有一个或两个字段个列表。如果有两个字段，则第一个是参数名而第二个是参数的默认值。&lt;/p&gt;
&lt;h3&gt;文件操作&lt;/h3&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;常用命令介绍
open
close
file
eof
gets
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;其他重要的命令&lt;/h3&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nv"&gt;format&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;按&lt;span class="nv"&gt;sprintf&lt;/span&gt;格式输出
&lt;span class="k"&gt;exec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;调用可执行程序
&lt;span class="nv"&gt;source&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;执行脚本
&lt;span class="nv"&gt;info&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;判断变量是否存在
&lt;span class="k"&gt;exit&lt;/span&gt;
&lt;span class="nv"&gt;expr&lt;/span&gt;
&lt;span class="nv"&gt;eval&lt;/span&gt;
&lt;span class="nv"&gt;incr&lt;/span&gt;
&lt;span class="nv"&gt;socket&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;#&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;tcp&lt;/span&gt;服务端客户端
&lt;span class="nv"&gt;encoding&lt;/span&gt;
&lt;span class="nv"&gt;dict&lt;/span&gt;
&lt;span class="nv"&gt;json&lt;/span&gt;


&lt;span class="nv"&gt;man&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="nv"&gt;tcl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;namespace&lt;/span&gt;
&lt;span class="nv"&gt;man&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="nv"&gt;tcl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;package&lt;/span&gt;
&lt;span class="nv"&gt;ls&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;share&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;man&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;zh_CN&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;man3&lt;/span&gt;&lt;span class="cm"&gt;/*tcl&lt;/span&gt;
&lt;span class="cm"&gt;rpm -ql tcl&lt;/span&gt;
&lt;span class="cm"&gt;rpm -ql tcllib&lt;/span&gt;
&lt;span class="cm"&gt;rpm -ql tclx&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="programming"></category><category term="programming"></category></entry><entry><title>gdb的基本使用方法</title><link href="/posts/2023/07/29/gdb.html" rel="alternate"></link><published>2023-07-29T00:26:32+08:00</published><updated>2023-07-30T22:41:38+08:00</updated><author><name>zhiliao</name></author><id>tag:None,2023-07-29:/posts/2023/07/29/gdb.html</id><summary type="html">&lt;h1&gt;获取进程的coredump （内核转储）&lt;/h1&gt;
&lt;h2&gt;启用内核转储&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;查看coredump功能是否有效&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ulimit&lt;/code&gt;和&lt;code&gt;ulimit -c&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;开启内核转储&lt;/td&gt;
&lt;td&gt;ulimit -c unlimited&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;设置coredump大小上限&lt;/td&gt;
&lt;td&gt;ulimit …&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</summary><content type="html">&lt;h1&gt;获取进程的coredump （内核转储）&lt;/h1&gt;
&lt;h2&gt;启用内核转储&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;查看coredump功能是否有效&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ulimit&lt;/code&gt;和&lt;code&gt;ulimit -c&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;开启内核转储&lt;/td&gt;
&lt;td&gt;ulimit -c unlimited&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;设置coredump大小上限&lt;/td&gt;
&lt;td&gt;ulimit -c 大小（Byte）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;gdb调试core文件&lt;/td&gt;
&lt;td&gt;gdb -c core.xxxx  ./a.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;检查是否是core文件&lt;/td&gt;
&lt;td&gt;file xxx输出core file&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;在专用目录中生成coredump&lt;/h2&gt;
&lt;p&gt;coredump保存位置的完整路径可以通过sysctl变量&lt;code&gt;kernel.core_pattern&lt;/code&gt;设置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;临时修改使用&lt;code&gt;echo /var/core/%t-%e-%p-%c.core &amp;gt; /proc/sys/kernel/core_pattern&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;或者&lt;code&gt;/etc/sysctl.conf&lt;/code&gt;中设置&lt;code&gt;kernel.core_pattern=/var/core/%t-%e-%p-%c.core&lt;/code&gt;。然后&lt;code&gt;sysctl -p&lt;/code&gt;让配置生效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;kernel.core_uses_pid=1 作用是在生成的core文件名字结尾添加&lt;code&gt;.PID&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;kernel.core_uses_pid=0则不添加。&lt;/p&gt;
&lt;h3&gt;kernel.core_pattern中可以设置的格式符&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;格式符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;%%&lt;/td&gt;
&lt;td&gt;%字符本身&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%p&lt;/td&gt;
&lt;td&gt;进程PID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%u&lt;/td&gt;
&lt;td&gt;进程的真实用户ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%g&lt;/td&gt;
&lt;td&gt;进程的真实组ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%s&lt;/td&gt;
&lt;td&gt;引发coredump的信号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%t&lt;/td&gt;
&lt;td&gt;转储时间戳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%h&lt;/td&gt;
&lt;td&gt;主机名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%e&lt;/td&gt;
&lt;td&gt;可执行文件名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%c&lt;/td&gt;
&lt;td&gt;转储文件大小上限&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;使用用户程序辅助自动压缩coredump文件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;kernel.core_pattern&lt;/code&gt;中可以加入管道符，管道符后面写程序名。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;echo "|/usr/local/sbin/core_helper %t %e %p %c" &amp;gt; /proc/sys/kernel/core_pattern&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;或者 sudo sysctl -w 'kernel.core_pattern=%t-%e-%p-%c.core'&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;或者 /etc/sysctl.conf&lt;code&gt;中设置&lt;/code&gt;kernel.core_pattern=|/usr/local/sbin/core_helper %t %e %p %c&lt;code&gt;。然后sysctl -p&lt;/code&gt;让配置生效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;core_heaper 文件内容很简单：&lt;/p&gt;
&lt;p&gt;cat core_heaper&lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;

&lt;span class="nb"&gt;exec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;gzip&lt;span class="w"&gt; &lt;/span&gt;-&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;/var/core/&lt;span class="nv"&gt;$1&lt;/span&gt;-&lt;span class="nv"&gt;$2&lt;/span&gt;-&lt;span class="nv"&gt;$3&lt;/span&gt;-&lt;span class="nv"&gt;$4&lt;/span&gt;.core
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;启用整个系统的coredump功能&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 service 文件 &lt;code&gt;[Service]&lt;/code&gt;中添加LimitCORE=infinity， 不制service服务core文件的大小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使SUID 程序也转储&lt;code&gt;sysctl -w 'fs.suid_dumpable=1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;systemd用户的coredumpctl&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装systemd-coredump &amp;amp;&amp;amp; reboot&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sudo coredumpctl list 列出当前corefile 文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sudo coredumpctl list 'smplayer' | tail -n 5&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/var/lib/systemd/coredump/ 这是corefile 默认保存位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;coredumpctl -o core dump PID # 获得转储信息，输出到文件core 中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;man systemd-coredump; man core 查看手册&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;利用内核转储掩码排除共享内存&lt;/h2&gt;
&lt;p&gt;有些程序会使用多个进程和几个G的共享内存，coredmp时间过长。&lt;/p&gt;
&lt;p&gt;在使用各个共享内存的进程中，共享内存的内容是相同的，没必要所有进程都转储共享内存。这种应用程序应当设置成只在某个进程中转储共享内存，其他进程无须转储。&lt;/p&gt;
&lt;p&gt;设置方法：echo 1 &amp;gt; &lt;code&gt;/proc/&amp;lt;PID&amp;gt;/coredump_filter&lt;/code&gt; （16进制）&lt;/p&gt;
&lt;p&gt;比特掩码对应的内存类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(bit 0) anonymous private memory（匿名私有内存段）&lt;/li&gt;
&lt;li&gt;(bit 1) anonymous shared memory（匿名共享内存段）&lt;/li&gt;
&lt;li&gt;(bit 2) file-backed private memory（file-backed 私有内存段）&lt;/li&gt;
&lt;li&gt;(bit 3) file-backed shared memory（file-bakced 共享内存段）&lt;/li&gt;
&lt;li&gt;(bit 4) ELF header pages in file-backed private memory areas (ELF 文件映射, it is effective only if the bit 2 is cleared)&lt;/li&gt;
&lt;li&gt;(bit 5) hugetlb private memory（大页面私有内存）&lt;/li&gt;
&lt;li&gt;(bit 6) hugetlb shared memory（大页面共享内存）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认的coredump_filter 的值一般是0x33&lt;/p&gt;
&lt;p&gt;要跳过所有的共享内存，可以设置为 &lt;code&gt;echo 1 &amp;gt; /proc//coredump_filter&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;调试器的基本使用方法&lt;/h1&gt;
&lt;h3&gt;调试前的准备：修改编译参数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;通过gcc的-g选项生成调试信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;gcc -Wall -O2 -g source.c&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;-ggdb 选项允许使用只有GDB才能使用的额外调试信息，包括gdb扩展&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-glevel | -ggdblevel `level取值范围 0 1 2 3。-g0不生成调试信息，否定-g。-g1生成调试信息最少，没有局部变量。-g2生成默认级别的调试信息。-g3包括额外的调试信息，支持宏定义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果使用Makefile构建，一般要求给CFLAGS中指定-g选项。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;CFLAGS = -Wall -O2 -g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果用configure脚本生成Makefile，可以这样用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;./configure CFLAGS="-Wall -O2 -g"&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;构建方法通常会写在INTALL, README等文件中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-Wall -Werror 选项可以在警告发生时，当成错误来处理&lt;/p&gt;
&lt;p&gt;-Wl,-Map=output.map #-Wl,的意思是把后面的参数传递给连接器，传递给连接器的参数列表需要紧跟-Wl,用逗号分隔，不能有带空格。-Wl,-Map=output.map的作用是生成map文件。map文件包含函数地址入口等信息，如果gcc编译时候没有带调试信息，可以用map来定位调用栈中的函数，也可以通过函数地址入口信息通过gdb或者代码调用函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;如何知道程序带调试信息&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;readelf -S ./a.out | grep \.debug&lt;/code&gt; 如果带.debug段说明有调试信息。&lt;/p&gt;
&lt;h2&gt;启动调试&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;gdb 可执行文件名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gdb --args ./a.out 可执行文件参数列表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gdb -p PID&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gdb -c corefile 可执行文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;设置断点&lt;/h2&gt;
&lt;p&gt;程序运行后，到达断点会自动暂停运行。&lt;/p&gt;
&lt;p&gt;断点命令break,简写b。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;break命令格式&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;break （在下一行代码上设置断点）&lt;/td&gt;
&lt;td&gt;break&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;break 函数名&lt;/td&gt;
&lt;td&gt;break sendto&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;break 行号&lt;/td&gt;
&lt;td&gt;break 516&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;break 文件名:行号&lt;/td&gt;
&lt;td&gt;break main.c:120&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;break +相对暂停位置的偏移量（行数）&lt;/td&gt;
&lt;td&gt;break +3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;break -相对暂停位置的偏移量（行数）&lt;/td&gt;
&lt;td&gt;break -5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;break *地址&lt;/td&gt;
&lt;td&gt;break *0x08116fd3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;设置好的断点可以通过 &lt;code&gt;info break [n]&lt;/code&gt;查看。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;delete [breakpoints] [n]&lt;/code&gt; 命令删除段店，breakpoints可有可无，n为断点编号，如果省略n则删除所有断点。&lt;/p&gt;
&lt;h2&gt;运行&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;run&lt;/td&gt;
&lt;td&gt;开始运行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;start&lt;/td&gt;
&lt;td&gt;开始运行，并在main上暂停，相当于自动给main设置断点然后开始运行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;set args [Arguments]&lt;/td&gt;
&lt;td&gt;设置进程启动参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;show args&lt;/td&gt;
&lt;td&gt;查看进程参数列表&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;显示代码&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;list&lt;/code&gt; 命令向下查看10行代码&lt;/p&gt;
&lt;p&gt;&lt;code&gt;list -&lt;/code&gt; 向上查看10行代码&lt;/p&gt;
&lt;p&gt;&lt;code&gt;list LINENUM&lt;/code&gt; 查看行号的代码&lt;/p&gt;
&lt;p&gt;&lt;code&gt;list FUNCTION&lt;/code&gt; 查看指定函数代码&lt;/p&gt;
&lt;p&gt;&lt;code&gt;list FILE:LINENUM&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;list FILE:FUNCTION&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;list *ADDRESS&lt;/code&gt; 按地址查看代码&lt;/p&gt;
&lt;h2&gt;显示调用栈&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;backtrace&lt;/td&gt;
&lt;td&gt;显示调用栈栈帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bt&lt;/td&gt;
&lt;td&gt;breaktrace的简写（别名）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;backtrace N&lt;/td&gt;
&lt;td&gt;只显示开头N个栈帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bt N&lt;/td&gt;
&lt;td&gt;只显示开头N个栈帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;backtrack -N&lt;/td&gt;
&lt;td&gt;只显示最后N个栈帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bt -N&lt;/td&gt;
&lt;td&gt;只显示最后N个栈帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;backtrace full&lt;/td&gt;
&lt;td&gt;不仅显示backtrace,还显示局部变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bt full&lt;/td&gt;
&lt;td&gt;不仅显示backtrace,还显示局部变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;backtrace full N&lt;/td&gt;
&lt;td&gt;不仅显示backtrace,还显示局部变量，N的含义同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bt full N&lt;/td&gt;
&lt;td&gt;不仅显示backtrace,还显示局部变量，N的含义同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;backtrace full N&lt;/td&gt;
&lt;td&gt;不仅显示backtrace,还显示局部变量，N的含义同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bt full -N&lt;/td&gt;
&lt;td&gt;不仅显示backtrace,还显示局部变量，N的含义同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;info stack&lt;/td&gt;
&lt;td&gt;backtrace的别名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;where&lt;/td&gt;
&lt;td&gt;backtrace的别名&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;显示局部变量和切换调用栈&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;info locals&lt;/code&gt; 显示局部变量&lt;/p&gt;
&lt;p&gt;&lt;code&gt;info args&lt;/code&gt; 查看函数参数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;info frame&lt;/code&gt;查看调用栈帧相关信息&lt;/p&gt;
&lt;p&gt;&lt;code&gt;up [N]&lt;/code&gt;  查看上一层函数调用栈，N为层数，默认是1&lt;/p&gt;
&lt;p&gt;&lt;code&gt;down [N]&lt;/code&gt; 查看下一层函数调用栈，N为层数，默认是1&lt;/p&gt;
&lt;p&gt;&lt;code&gt;frame &amp;lt;栈帧N&amp;gt;&lt;/code&gt;  N为bt命令显示的编号，查看第N个调用栈&lt;/p&gt;
&lt;p&gt;&lt;code&gt;frame&lt;/code&gt; 切换到当前线程正在执行的调用栈&lt;/p&gt;
&lt;h2&gt;显示变量&lt;/h2&gt;
&lt;p&gt;print命令可以显示变量，简写p。&lt;/p&gt;
&lt;p&gt;格式： print 变量。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;th&gt;显示&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;p argv&lt;/td&gt;
&lt;td&gt;(char**)0xbf9cd714&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;p *argv&lt;/td&gt;
&lt;td&gt;"./a.out"&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;p argv[0]&lt;/td&gt;
&lt;td&gt;"./a.out"&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;p argv[1]&lt;/td&gt;
&lt;td&gt;"hello"&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;自动显示变量的值&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;display&lt;/code&gt; 命令用于监视变量或者内存的值，每次 gdb 中断，都会自动输出这些被监视变量或内存的值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;display命令的使用格式是 &lt;code&gt;display 变量名/内存地址/寄存器名&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;info display&lt;/code&gt; # 查看display设置的自动显示的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;undisplay &amp;lt;编号&amp;gt; # 取消自动显示变量（info display时显示的编号）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;delete display range… # range为编号，或者空格分割的编号，或者 编号-编号，用来删除一个范围&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;查看寄存器&lt;/h2&gt;
&lt;p&gt;info registers可以查看寄存器，简写为info reg。&lt;/p&gt;
&lt;p&gt;在寄存器名称前加上$, 可以用p命令查看寄存器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;p $rax&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;程序指针可以写为 &lt;code&gt;$pc&lt;/code&gt;, 也可以写为 &lt;code&gt;$eip&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;p   $pc&lt;/code&gt; 能够常看当前执行的程序地址。&lt;/p&gt;
&lt;p&gt;print 命令支持选择显示的格式。&lt;code&gt;print/c $rax&lt;/code&gt; &lt;code&gt;p/u $rdx&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;print命令可以使用的显示格式&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;格式&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;显示为16进制数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;显示为十进制数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u&lt;/td&gt;
&lt;td&gt;显示为无符号十进制数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;o&lt;/td&gt;
&lt;td&gt;显示为8进制数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t&lt;/td&gt;
&lt;td&gt;显示为2进制数字，t的由来是two&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;显示地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;显示为字符（ASCII）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;f&lt;/td&gt;
&lt;td&gt;显示为浮点小数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;显示为字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;显示为汇编语言。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;查看内存&lt;/h2&gt;
&lt;p&gt;x命令可以显示内存中的内容。x这个名字的由来是eXamining.&lt;/p&gt;
&lt;p&gt;格式： &lt;code&gt;x/格式 地址&lt;/code&gt;  &lt;code&gt;x /格式 寄存器&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一般使用x命令时，格式为 &lt;code&gt;x/NFU ADDR&lt;/code&gt;。addr为希望显示的地址。N为重复次数，F为上一节中的显示格式（x,d,u,o,t,a,c,f,s,i）。U下是面的单位。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;U代表的单位&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;h&lt;/td&gt;
&lt;td&gt;半字（2字节）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;w&lt;/td&gt;
&lt;td&gt;字（4字节，默认值）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;g&lt;/td&gt;
&lt;td&gt;双字（8字节）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;显示&lt;code&gt;$pc&lt;/code&gt;所指地址开头的10条指令： &lt;code&gt;x /10i $pc&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;反汇编指令 disassemble&lt;/h3&gt;
&lt;p&gt;反汇编指令 disassemble,简写为disas。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;格式&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;disas&lt;/td&gt;
&lt;td&gt;反汇编当前整个函数&lt;/td&gt;
&lt;td&gt;disas&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disas 程序计数器&lt;/td&gt;
&lt;td&gt;反汇编程序计数器所在的函数整个函数&lt;/td&gt;
&lt;td&gt;disas $pc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disas 开始地址 结束地址&lt;/td&gt;
&lt;td&gt;反汇编从开始地址到结束地址之间的部分&lt;/td&gt;
&lt;td&gt;&lt;code&gt;disas $pc $pc+50&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;单步执行&lt;/h2&gt;
&lt;p&gt;单步执行的意思是根据代码一行一行的执行。&lt;/p&gt;
&lt;p&gt;单步执行命令为next,简写n.&lt;/p&gt;
&lt;p&gt;进入函数内部的单步命令为step,简写为p.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;简写&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;next&lt;/td&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;执行下一行。执行完毕后显示再下一行的源码。不会进入下一行中的函数内部。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;step&lt;/td&gt;
&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;执行下一行，但会进入下一行中函数内部。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nexti&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;逐条执行汇编指令 ，不会进入函数内部。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stepi&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;逐条执行汇编指令 ，会进入函数内部。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;继续运行&lt;/h2&gt;
&lt;p&gt;continue命令（简写c）可以继续运行程序。程序会在遇到断点后再次暂停运行。如果没有断点，就会一直运行到结束。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;continue&lt;/td&gt;
&lt;td&gt;继续运行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;continue 次数&lt;/td&gt;
&lt;td&gt;指定次数忽略遇到的断点。例如continue 5，遇到5次断点不暂停运行。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;监视点&lt;/h2&gt;
&lt;p&gt;watch命令可以找到&lt;strong&gt;变量或内存&lt;/strong&gt;在何时被改变或访问。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;awatch &amp;lt;表达式&amp;gt;&lt;/td&gt;
&lt;td&gt;表达式被访问，改变时暂停运行。即watch和rwatch。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;watch &amp;lt;表达式&amp;gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;表达式发生变化是暂停运行。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rwatch &amp;lt;表达式&amp;gt;&lt;/td&gt;
&lt;td&gt;表达式被访问是暂停运行。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;表达式的的意思是常量或者变量。例如&lt;code&gt;watch name&lt;/code&gt;  &lt;code&gt;watch argv[0]&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;删除断点和监视点&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;info b&lt;/td&gt;
&lt;td&gt;显示断点和监视点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;delete &amp;lt;编号&amp;gt;&lt;/td&gt;
&lt;td&gt;删除指定的断点或监视点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;delete&lt;/td&gt;
&lt;td&gt;删除所有断点和监视点&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;其他断点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;硬件断点&lt;code&gt;hbreak&lt;/code&gt;，适用于ROM空间等无法修改的内存区域中的程序，在有些架构中无法使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;临时断点 &lt;code&gt;tbreak&lt;/code&gt;和临时硬件断点&lt;code&gt;thbreak&lt;/code&gt;，与断点（硬件断点）基本相同，不同之处是临时断点会在到达断点程序暂停时被删除，所以只需要暂停一次时候使用起来很方便。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;遗憾的是没有临时监视点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;改变变量的值&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;set variable &amp;lt;变量&amp;gt;=&amp;lt;表达式&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;set variable num=0&lt;/code&gt; 将num的值设置为0&lt;/p&gt;
&lt;h2&gt;生成coredump文件&lt;/h2&gt;
&lt;p&gt;gdb中 &lt;code&gt;generate-core-file&lt;/code&gt;命令在当前目录下生成coredump文件，可以写为&lt;code&gt;gcore&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;linux shell中 &lt;code&gt;gcore [-a] pid1 [pid2...pidN]&lt;/code&gt; 命令可以根据进程PID生成coredump文件。&lt;/p&gt;
&lt;p&gt;例如&lt;code&gt;gcore $(pidof emacs)&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;attach到进程&lt;/h2&gt;
&lt;p&gt;attachh &lt;PID&gt;可以attach到指定进程，和gdb -p &lt;PID&gt;效果类似。&lt;/p&gt;
&lt;p&gt;detach 命令可以脱离调试的进程。&lt;/p&gt;
&lt;p&gt;attach后，进程暂停运行，此时可以通过bt命令查看backtrace, 通过continue命令继续运行程序。&lt;/p&gt;
&lt;p&gt;进程信息可以用&lt;code&gt;info proc&lt;/code&gt;命令查看。&lt;/p&gt;
&lt;h2&gt;条件断点&lt;/h2&gt;
&lt;p&gt;有一种断点仅在特定条件下中断。&lt;/p&gt;
&lt;p&gt;格式：&lt;code&gt;break 断点 if 条件&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这条命令将测试给定的条件，如果为真则暂停运行。&lt;/p&gt;
&lt;p&gt;例&lt;code&gt;break iseq_compile if node==0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;condition 断点编号&lt;/code&gt; #这条命令可以删除指定断点的出发条件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;condition 断点编号 条件&lt;/code&gt; # 这条命令给指定的断点增加出发条件。&lt;/p&gt;
&lt;h2&gt;反复执行&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ignore &amp;lt;断点编号&amp;gt; &amp;lt;次数&amp;gt;&lt;/td&gt;
&lt;td&gt;在指定的断点，监视点，或捕获点忽略指定的次数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;continue &amp;lt;次数&amp;gt;&lt;/td&gt;
&lt;td&gt;忽略指定次数，到达断点，监视点，捕获点不暂停运行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;step 次数&lt;/td&gt;
&lt;td&gt;单步运行次数（进入函数）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stepi 次数&lt;/td&gt;
&lt;td&gt;单步运行汇编代码，进入函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;next 次数&lt;/td&gt;
&lt;td&gt;单步运行次数（不进入函数）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nexti 次数&lt;/td&gt;
&lt;td&gt;单步运行汇编代码，不进入函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;finish&lt;/td&gt;
&lt;td&gt;执行完当前的函数后暂停&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;until&lt;/td&gt;
&lt;td&gt;执行完当前的代码块，或者执行完循环后暂停，常用于跳出循环&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;return 表达式&lt;/td&gt;
&lt;td&gt;结束当前函数调用并返回指定的值，回到上一层函数调用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;jump LINE&lt;/td&gt;
&lt;td&gt;跳转到指定的行执行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;jump *ADDR&lt;/td&gt;
&lt;td&gt;跳转到指定的地址执行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;删除断点和禁用断点&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;clear 函数名&lt;/td&gt;
&lt;td&gt;删除函数中的断点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clear 行号&lt;/td&gt;
&lt;td&gt;删除源码行号上的断点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clear 文件名:函数名&lt;/td&gt;
&lt;td&gt;删除指定文件函数中的断点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clear 文件名:行号&lt;/td&gt;
&lt;td&gt;删除源码行号上的断点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clear *程序地址&lt;/td&gt;
&lt;td&gt;删除位于地址的断点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;delete [breakpoints] 断点编号&lt;/td&gt;
&lt;td&gt;删除指定编号的断点， breakpoints关键字可以省略&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;delete [breakpoints]&lt;/td&gt;
&lt;td&gt;删除所有断点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disable [breakpoints]&lt;/td&gt;
&lt;td&gt;临时禁用所有断点，后面还能再启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disable [breakpoints] 断点编号&lt;/td&gt;
&lt;td&gt;临时禁用指定的断点，后面还能再启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disable diaplay 显示编号&lt;/td&gt;
&lt;td&gt;禁用display命令定义的自动显示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disable mem 内存区域&lt;/td&gt;
&lt;td&gt;禁用mem命令定义的内存区域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;enable [breakpoints]&lt;/td&gt;
&lt;td&gt;启用被禁用的所有断点。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;enable [breakpoints] 断点编号&lt;/td&gt;
&lt;td&gt;启用指定断点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;enable [breakpoints] once 断点编号&lt;/td&gt;
&lt;td&gt;启用一次断点，随后禁用断点。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;enable [breakpoints] delete 断点编号&lt;/td&gt;
&lt;td&gt;启用一次断点，随后删除断点。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;enable diaplay 显示编号&lt;/td&gt;
&lt;td&gt;启用display命令定义的自动显示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;enable mem 内存区域&lt;/td&gt;
&lt;td&gt;启用mem命令定义的内存区域&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;显示变量类型和定义变量的文件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;whatis 表达式&lt;/code&gt; # 显示变量类型声明&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ptype 表达式&lt;/code&gt; # 显示变量类型定义&lt;/p&gt;
&lt;h1&gt;调试多线程&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;info threads&lt;/code&gt; 查看所有线程列表&lt;/p&gt;
&lt;p&gt;&lt;code&gt;thread N&lt;/code&gt; 切换到指定线程&lt;/p&gt;
&lt;h1&gt;参考资料&amp;amp;其他学习资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;《DEBUG HACKS中文版》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://visualgdb.com/gdbreference&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;man gdb&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://sourceware.org/gdb/onlinedocs/gdb/"&gt;Debugging with GDB&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.kancloud.cn/wizardforcel/gdb-tips-100/146724"&gt;100个gdb小技巧 &lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://m.biancheng.net/gdb/"&gt;GDB调试教程：1小时玩转Linux gdb命令&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="programming"></category><category term="debug"></category><category term="programming"></category><category term="linux"></category><category term="C"></category></entry><entry><title>解决linux下Qt creator不显示qDebug输出</title><link href="/posts/2022/07/04/qt-creator-qDebug.html" rel="alternate"></link><published>2022-07-04T18:50:55+08:00</published><updated>2023-02-21T09:52:21+08:00</updated><author><name>zhiliao</name></author><id>tag:None,2022-07-04:/posts/2022/07/04/qt-creator-qDebug.html</id><summary type="html">&lt;p&gt;linux下Qt creator 不显示qDebug输出， 可以在qtcreator的.desktop文件添加环境变量。
&lt;code&gt;env QT_ASSUME_STDERR_HAS_CONSOLE=1 qtcreator&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;源代码原编写于Windows系统中，迁移到Linux上后使 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;linux下Qt creator 不显示qDebug输出， 可以在qtcreator的.desktop文件添加环境变量。
&lt;code&gt;env QT_ASSUME_STDERR_HAS_CONSOLE=1 qtcreator&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;源代码原编写于Windows系统中，迁移到Linux上后使用同一个qt工程文件进行编译，程序可以运行，但是无法输出QDebug信息。可能是Linux默认禁用了Qt的调试信息处理程序。&lt;/p&gt;
&lt;p&gt;解决方案如下：&lt;/p&gt;
&lt;p&gt;在主程序源代码添加&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;QLoggingCategory::defaultCategory()-&amp;gt;setEnabled(QtDebugMsg, true);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相关的讨论如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://forum.qt.io/topic/81430/unable-to-see-the-qdebug-messages-on-console/15&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果采用另一种方法，即在终端设置环境变量&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;export QT_LOGGING_RULES="*.debug=true"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么会有大量诸如鼠标事件、界面状态等不属于QDebug输出信息之外的内容打印在终端上。&lt;/p&gt;</content><category term="programming"></category><category term="programming"></category><category term="Qt"></category></entry><entry><title>统计代码行数cloc (count lines of code)</title><link href="/posts/2022/06/29/cloc.html" rel="alternate"></link><published>2022-06-29T17:17:17+08:00</published><updated>2022-07-26T18:17:52+08:00</updated><author><name>zhiliao</name></author><id>tag:None,2022-06-29:/posts/2022/06/29/cloc.html</id><content type="html">&lt;p&gt;统计代码行数可以使用cloc，gocloc&lt;/p&gt;
&lt;h4&gt;使用cloc&lt;/h4&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;apt&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;cloc
cloc&lt;span class="w"&gt; &lt;/span&gt;.
cloc&lt;span class="w"&gt; &lt;/span&gt;xxx-source.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;使用gocloc&lt;/h4&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# https://github.com/hhatto/gocloc&lt;/span&gt;
gocloc&lt;span class="w"&gt; &lt;/span&gt;.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="programming"></category><category term="programming"></category></entry><entry><title>关于Qt</title><link href="/posts/2022/04/11/about-qt.html" rel="alternate"></link><published>2022-04-11T14:48:07+08:00</published><updated>2023-02-21T09:52:21+08:00</updated><author><name>zhiliao</name></author><id>tag:None,2022-04-11:/posts/2022/04/11/about-qt.html</id><content type="html">&lt;p&gt;QString转char*的正确方法&lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;QString&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toLocal8Bit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;constData&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;QString&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toUtf8&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;constData&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="programming"></category><category term="programming"></category></entry><entry><title>C++书籍推荐</title><link href="/posts/2015/01/01/cpp-books.html" rel="alternate"></link><published>2015-01-01T00:00:00+08:00</published><updated>2023-02-21T09:52:21+08:00</updated><author><name>zhiliao</name></author><id>tag:None,2015-01-01:/posts/2015/01/01/cpp-books.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;C++Primer 5th 中文版 (no Plus)&lt;/li&gt;
&lt;li&gt;Inside C++ Object Model&lt;/li&gt;
&lt;li&gt;The Design and Evolution of C++&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这三本就够用了，可以应付绝大多数的工作&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下面是转载的在博客上看到的一 …&lt;/p&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;C++Primer 5th 中文版 (no Plus)&lt;/li&gt;
&lt;li&gt;Inside C++ Object Model&lt;/li&gt;
&lt;li&gt;The Design and Evolution of C++&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这三本就够用了，可以应付绝大多数的工作&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下面是转载的在博客上看到的一个C++书籍阅读清单，可以参考下：&lt;/p&gt;
&lt;h2&gt;阶段 1&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;《Essential C++》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是一本内容不多但很实用的C++入门书籍，强调快速上手与理解C++编程。本书主要围绕一系列逐渐复杂的程序问题，以及用以解决这些问题的语言特性展开讲解。你不只学到C++的函数和结构，也会学习到它们的设计目的和基本原理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《C++ Primer》（不是 plus）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本书对C++基本概念、技术、以及现代C++编程风格进行了全面而且权威的阐述，是C++初学者的最佳指南；本书可以帮助你编写实用的程序，而无需首先精通每个语言细节。对于中高级程序员，本书也是不可或缺的参考书。&lt;/p&gt;
&lt;h2&gt;阶段 2&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;《Effective C++》和《More effective C++》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作者是Scott Meyers。你应该熟读它们，并清楚地理解每个项目。该书围绕55条准则，每一条都介绍了一个可让你写出更好的C++程序代码的方法，并以特别设计过的例子详加讨论。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Exceptional C++（C++编程剖析）》和《More exceptional C++》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两本书中都包含了40个C++编程问题，这些问题会让你磨练自己的技能，最终成为优秀的C++程序员。这些问题是Herb Sutter精心挑选，与ISO/ANSI C++官方标准相一致，帮助程序员在设计、架构和编码过程中保持良好的风格，从而使编写的C++软件更健壮、更高效。&lt;/p&gt;
&lt;h2&gt;阶段 3&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;《Inside the C++ object model（深度探索C++对象模型）》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本书专注于C++面向对象程序设计的底层机制，包括结构式语意、临时性对象的生成、封装、继承，以及虚拟——虚拟函数和虚拟继承，帮助你理解程序的底层实现，以便写出更高效的代码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《The design and evolution of C++（C++语言的设计与演化）》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本书作者也是C++语言的设计者Bjarne Stroustrup，作者在书中综合性地介绍了C++的发展历史，C++中各种重要机制的本质意义和设计背景，这些机制的基本用途和使用方法，讨论了C++所适合的应用领域及其未来的发展前景，既没有忽略关键性的详情，又没有过多地陷入技术细节。&lt;/p&gt;
&lt;h2&gt;阶段 4&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;《The C++ standard library（C++标准程序库）》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是标准模板库字典，你可以在本书中找到STL相关的一切知识。本书焦点放在标准模板库、检查容器、迭代器、函数对象和STL算法上。每一个元素都有深刻的呈现，包括其介绍、设计、运用实例、细节解说、陷阱、意想不到的危险，以及相关类别和函数等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Effective STL》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是Scott Meyers的第三本C++专著，也是学习STL最权威的书籍。作者对书中的50个指导方针都作了详尽的分析，并配以示例。通过这些规则，C++开发者可以最大限度地使用STL。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Generic programming and the STL（泛型编程与STL）》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本书阐述了泛型程序设计的核心理念：concepts（概念）、modeling（模型）和refinement（改善），并为你展示这些观念如何导出STL的基础概念：iterators（迭代器）、containers（容器）和function objects（函数对象）。按照本书所述，你可以把STL想象成一个由concepts组成的library，你将学习到STL正式结构并理解其强大的优势。&lt;/p&gt;
&lt;h2&gt;阶段 5&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;《Exceptional C++ style》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作者为Herb Sutter。本书同样提出了40个C++风格相关的问题，对一些至关重要的C++细节和相互关系提出了新的见解，为当今的关键C++编程技术（如泛型编程、STL、异常安全等）提供了新的策略，帮助开发者在开销与功能之间、优雅与可维护性之间、灵活性与过分灵活之间寻找完美的平衡点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《C++ template》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是一本关于C++模板的完整的参考手册和教程，它强调模板的使用实践，包含了现实世界中的例子。每个C++程序员都应该好好读一读这本书。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Modern C++ design（现代C++设计）》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作者Andrei Alexandrescu为C++程序员打开了一个新的局面。本书提供了一些针对软件设计的前沿方法，如联合设计模式、泛型编程，使程序员可以编写有表现力的、灵活的、高度可重用的代码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Thinking in C++（C++编程思想）》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ 领域权威著作，介绍了C++实用的编程技术和最佳的实践方法。&lt;/p&gt;</content><category term="programming"></category><category term="programming"></category><category term="C++"></category><category term="book"></category></entry><entry><title>C语言深度解剖</title><link href="/posts/2014/08/06/programming-C.html" rel="alternate"></link><published>2014-08-06T00:00:00+08:00</published><updated>2023-02-21T09:52:21+08:00</updated><author><name>zhiliao</name></author><id>tag:None,2014-08-06:/posts/2014/08/06/programming-C.html</id><summary type="html">&lt;p&gt;register 变量必须是一个单个的值，并且其长度应小于或等于整型的长度。 而且 register 变量可能不存放在内存中，所以不能用取址运 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;register 变量必须是一个单个的值，并且其长度应小于或等于整型的长度。 而且 register 变量可能不存放在内存中，所以不能用取址运算符“&amp;amp;”来获取 register 变量的地址。
 
static 静态全局变量，作用域仅限于变量被定义的文件中，其他文件即使用 extern 声明也没法
使用他。准确地说作用域是从定义之处开始，到文件结尾处结束，在定义之处前面的那些
代码行也不能使用它。想要使用就得在前面再加 extern ***。恶心吧？要想不恶心，很简单，
直接在文件顶端定义不就得了。&lt;/p&gt;
&lt;p&gt;静态局部变量，在函数体里面定义的，就只能在这个函数里用了，同一个文档中的其他
函数也用不了。由于被 static 修饰的变量总是存在内存的静态区，所以即使这个函数运行结
束，这个静态变量的值还是不会被销毁，函数下次使用时仍然能用到这个值。&lt;/p&gt;
&lt;p&gt;函数前加 static 使得函数成为静态函数。但此处“static”的含义不是指存储方式，而是指对函数的作用域仅局限于本文件(所以又称内部函数)。使用内部函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其它文件中的函数同名。
 
关键字 static 有着不寻常的历史。起初，在 C 中引入关键字 static 是为了表示退出一个
块后仍然存在的局部变量。随后，static 在 C 中有了第二种含义：用来表示不能被其它文件访问的全局变量和函数。为了避免引入新的关键字，所以仍使用 static 关键字来表示这第二种含义。
 
 
对在多个文件之间共同使用的全局变量或函数要加范围限定符(建议使用模块名
(缩写)作为范围限定符)。(GUI_ ，etc)
 
 特别注意的就是 1（数字 1）和 l（小写字母 l）之间，0（数字 0）和 o
（小写字母 o）之间的区别&lt;/p&gt;
&lt;p&gt;所有宏定义、枚举常数、只读变量全用大写字母命名，用下划线分割单词。&lt;/p&gt;
&lt;p&gt;float 变量与“零值”进行比较的 if 语句怎么写？
  
同样的也不要在很大的浮点数和很小的浮点数之间进行运算
 
一般来说习惯上用 n,m,i,j,k 等表示 int 类型的变量；c，ch 等表示字符类型变量；a 等表
示数组；p 等表示指针。当然这仅仅是一般习惯，除了 i,j,k 等可以用来表示循环变量外，别
的字符变量名尽量不要使用。 &lt;/p&gt;
&lt;p&gt;程序中不得出现仅靠大小写区分的相似的标识符。&lt;/p&gt;
&lt;p&gt;定义变量的同时千万千万别忘了初始化。定义变量时编译器并不一定清空了 这块内存，它的值可能是无效的数据。&lt;/p&gt;
&lt;p&gt;case 后面只能是整型或字符型的常量或常量表达式（想想字符型数据在内存里
是怎么存的
 
有时候，你只剩下了最后一种情况需要处理，于是就决定把这种情况用 default 子句来
处理。这样也许会让你偷懒少敲几个字符，但是这却很不明智。这样将失去 case 语句的标
号所提供的自说明功能，而且也丧失了使用 default 子句处理错误情况的能力。
 
 
在多重循环中，如果有可能，应当将最长的循环放在最内层，最短的循环放
在最外层，以减少 CPU 跨切循环层的次数
 
长循环在最内层，效率高&lt;/p&gt;
&lt;p&gt;当循环嵌套超过 3 层，程序员对循环的理解能力会极大的降低。&lt;/p&gt;
&lt;p&gt;void *则不同，任何类型的指针都可以直接赋值给它，无需进行强制类型转换：&lt;/p&gt;
&lt;p&gt;在 C 语言中，凡不加返回值类型限定的函数，就会被编译器作为返回整型值处理&lt;/p&gt;
&lt;p&gt;在 C 语言中，可以给无参数的函数传送任意类型的参数，
但是在 C++编译器中编译同样的代码则会出错
无论在 C 还是 C++中，若函数不接受任何参数，一定要指明参数为 void。
 &lt;/p&gt;
&lt;p&gt;要求余数与被除数的正负号相同&lt;/p&gt;</content><category term="programming"></category><category term="programming"></category><category term="C"></category></entry><entry><title>apue读书笔记</title><link href="/posts/2014/06/23/apue-note.html" rel="alternate"></link><published>2014-06-23T00:00:00+08:00</published><updated>2023-02-21T09:52:21+08:00</updated><author><name>zhiliao</name></author><id>tag:None,2014-06-23:/posts/2014/06/23/apue-note.html</id><summary type="html">&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;打印出错信息：
Strerror  perror
一个unix惯例是把argv[0]作为参数传递给perror
好处是当用管道连接多个程序时，能分清错误是哪一个产生 …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;打印出错信息：
Strerror  perror
一个unix惯例是把argv[0]作为参数传递给perror
好处是当用管道连接多个程序时，能分清错误是哪一个产生的。

可以free（NULL）

 fork  ，pthread create 之前要fflsh(null) 刷新缓存区
否则可能会输出两次
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="programming"></category><category term="programming"></category><category term="python"></category></entry><entry><title>C语言零长数组</title><link href="/posts/2014/03/23/zero-length-array.html" rel="alternate"></link><published>2014-03-23T18:28:00+08:00</published><updated>2023-02-21T09:52:21+08:00</updated><author><name>zhiliao</name></author><id>tag:None,2014-03-23:/posts/2014/03/23/zero-length-array.html</id><summary type="html">&lt;p&gt;前言：计算机语言是编译器和程序员交流的依据和规范，GNU C是GCC特有的功能，在Linux内核中被广泛应用。&lt;/p&gt;
&lt;p&gt;帮助文档：http://gcc.gnu.org …&lt;/p&gt;</summary><content type="html">&lt;p&gt;前言：计算机语言是编译器和程序员交流的依据和规范，GNU C是GCC特有的功能，在Linux内核中被广泛应用。&lt;/p&gt;
&lt;p&gt;帮助文档：http://gcc.gnu.org/onlinedocs/gcc-4.6.2/gcc/C-Extensions.html#C-Extensions&lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;int *p;
p=(int[]){99};
GCC 临时变量
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;1、零长数组&lt;/h2&gt;
&lt;p&gt;GNU C允许声明长度为零的数组，但它只能被用于结构体的最后一个成员。&lt;/p&gt;
&lt;p&gt;举例，如清单1： &lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include &lt;/span&gt;
&lt;span class="cp"&gt;#include &lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;letter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;thisline&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;thisline&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;thisline&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;letter&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sizeof(struct line) = %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;line&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;thisline&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%c &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;thisline&lt;/span&gt;&lt;span class="o"&gt;-&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;例子输出结果： &lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sizeof(struct line) = 4  
A B C D E F G H I
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如例子中的第6行，contents就是一个零长数组，在sizeof看来它所占的空间为零。&lt;/p&gt;
&lt;h2&gt;在ISO C99中，使用变长数组也可以实现同样的功能，如清单2：&lt;/h2&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="n"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="nc"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="err"&gt;[]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;thisline&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;4&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;5&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;sizeof(struct line) = %d\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;sizeof(thisline) = %d\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;thisline&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;thislinelengthispan&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;%c &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;thisline&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;例子输出结果： &lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sizeof(struct line) = 4  
sizeof(thisline) = 4  
1 2 3 4 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;变长数组是不完全数据类型，不能使用sizeof获得它的大小。&lt;/p&gt;
&lt;p&gt;注意，此结构体的变量必须在函数外定义和初始化，否则会报错： &lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;non&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;initialization&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;of&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;flexible&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;near&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;initialization&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;thisline&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;不能使用这样的形式：&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;

&lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mystruct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="n"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;[];&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="o"&gt;};&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;否则会报错：&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;flexible&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;otherwise&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;struct&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2、变长数组&lt;/h3&gt;
&lt;p&gt;在支持变长数组之前，C语言数组的大小是在声明时确定的（下标是一个常量表达式）并一直保持不变。所谓变长数组就是指数组的大小可以在运行时指定，如清单3： &lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;scanf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;%d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;sizeof(arr[%d]) = %d\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;例子输出结果： &lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sizeof(arr[6]) = 24 //输入数字6
sizeof(arr[9]) = 36 //输入数字9
    输入不同的值，数组的大小随之改变。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;变长数组作为参数进行传递的例子，如清单4： &lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;total&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;numispan&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;total&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;total&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="err"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;a[] total value: %d\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;b[] total value: %d\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;例子输出结果：&lt;/p&gt;
&lt;div class="highlight-custom"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;a[] total value: 10  
b[] total value: 45  
    函数sum形参中的arr可以匹配任意的一维整型数组。
    注意，num一定要声明在变长数组arr之前。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="programming"></category><category term="programming"></category><category term="C"></category></entry></feed>